## Graph
- 코딩 테스트에 자주 출제되는 Graph 관련 문제들입니다.
- 어떤 유형이 있는지는 하나씩 정리해나가도록 하겠습니다.

## 1. DFS
-

## 2. BFS
-

## 3. 플로이드-워샬 알고리즘
-

## 4. 백트래킹
- 

## 5. 다익스트라 알고리즘
- 그래프 내의 출발 노드에서 도착 노드까지의 최단 거리를 탐색하는 알고리즘이다.
- 그래프는 노드(node)와 간선(edge)으로 이루어져 있으며, 각 간선마다 가중치(weight)가 부여될 수 있다.
- 그래프의 간선 중 **음의 가중치**를 갖는 간선이 있는 경우, 다익스트라 알고리즘을 **사용할 수 없다**.
- 다음은 다익스트라 알고리즘의 동작 원리이다.
    1. 입력으로 그래프가 주어진다. 다익스트라 알고리즘과 함께 주로 사용되는 그래프는 크게 **인접 리스트**, **인접 행렬**이 있다.
        ```python
        # 인접 리스트(Adjacency List)
        # 각 정점마다 해당 정점에 인접한 정점들과 가중치를 리스트, 딕셔너리 등으로 표현하는 방법.
        # 희소 그래프(Sparse Graph, 그래프에 필요없는 값이 많음)에 적합.
        # 메모리 효율적
        {
            'A': {'B': 2, 'C': 4},
            'B': {'A': 2, 'C': 1, 'D': 7},
            'C': {'A': 4, 'B': 1, 'D': 3},
            'D': {'B': 7, 'C': 3}
        }
        ```
        ```python
        # 인접 행렬(Adjacency Matrix)
        # 정점 간의 연결 관계를 이차원 배열로 표현
        # 밀집 그래프(Dense Graph, 그래프에 필요한 값들이 대부분인 경우), 간선의 수가 많은 경우 적합
               A   B   C   D
            A  0   2   4   ∞
            B  2   0   1   7
            C  4   1   0   3
            D  ∞   7   3   0
        ```
    2. 모든 정점까지의 거리(또는 가중치의 합)를 초기화한 배열을 선언한다. 이 때 배열의 값은 주로 무한대를 사용한다.
    3. 2번에서 선언한 배열 중 출발 노드의 거리는 0으로 초기화한다. 출발 노드부터 거리를 계산하기 때문이다.
    4. 우선순위 큐에 출발 노드의 정보를 저장한다.
    5. 우선순위 큐에서 노드를 가져온다.
    6. 가져온 노드의 인접 노드들의 정보를 가져와서, 누적 가중치를 계산한다. 계산한 누적 가중치는 출발 노드부터 인접 노드까지 가중치의 합을 의미한다.
    7. 계산한 누적 가중치와 거리 배열에 저장되어있는 누적 가중치를 비교한다. 전자가 후자보다 작을 경우,
    거리 배열을 새로 계산한 누적 가중치로 초기화하고 해당 노드의 정보를 큐에 추가한다. 큐에 추가하는 이유는 모든 경우의 수를 확인해 최단 경로를 찾기 위함이다(그래서 다익스트라는 그리디 알고리즘이기도 하다).
    8. 큐가 빌 때까지 5 - 7 과정을 반복한다.
- 다익스트라 알고리즘의 코드 예시이다.
```python
def dijkstra(graph, start):
    dists = {node: float('inf') for node in graph.keys()} # 2
    dists[start] = 0 # 3

    queue = [(0, start)] # 4

    while queue: # 8
        # 5
        # 파이썬에서는 heapq 모듈로 min heap 자료구조를 이용하여 다익스트라를 구현한다.
        # min heap은 최소 값이 root node인 자료구조이다 -> 거리가 최소인 노드를 우선순위로 사용하는 큐라고 생각할 수 있다.
        curr_dist, curr_node = heapq.heappop(queue)

        # 과정을 반복하면서 큐에 동일한 노드에 대한 정보가 누적되는데, 불필요한 연산을 줄이기 위해 예외처리가 필요하다.
        if curr_dist > dists[curr_node]:
            continue

        for next_node, weight in graph[curr_node].items(): # 6
            dist = curr_dist + weight # 6

            if dist < dists[next_node]: # 7
                dists[next_node] = dist 
                heapq.heappush(queue, (dist, next_node))
```